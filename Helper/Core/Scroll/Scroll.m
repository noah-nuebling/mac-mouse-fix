//
// --------------------------------------------------------------------------
// ScrollControl.m
// Created for Mac Mouse Fix (https://github.com/noah-nuebling/mac-mouse-fix)
// Created by Noah Nuebling in 2020
// Licensed under the MMF License (https://github.com/noah-nuebling/mac-mouse-fix/blob/master/LICENSE)
// --------------------------------------------------------------------------
//

#import "Scroll.h"
#import "DeviceManager.h"
#import "TouchSimulator.h"
#import "ScrollModifiers.h"
#import "Config.h"
#import "ScrollUtility.h"
#import "VectorUtility.h"
#import "HelperUtility.h"
#import "WannabePrefixHeader.h"
#import "ScrollAnalyzer.h"
#import "ScrollConfigObjC.h"
#import <Cocoa/Cocoa.h>
#import "Queue.h"
#import "Mac_Mouse_Fix_Helper-Swift.h"
#import "SubPixelator.h"
#import "GestureScrollSimulator.h"
#import "SharedUtility.h"
#import "ScrollModifiers.h"
#import "Actions.h"
#import "EventUtility.h"

@import IOKit;
#import "MFHIDEventImports.h"
#import "IOUtility.h"

@implementation Scroll

#pragma mark - Variables - static

static CFMachPortRef _eventTap;
static CGEventSourceRef _eventSource;

static dispatch_queue_t _scrollQueue;

static TouchAnimator *_animator;

static AXUIElementRef _systemWideAXUIElement; // TODO: should probably move this to Config or some sort of OverrideManager class
+ (AXUIElementRef) systemWideAXUIElement {
    return _systemWideAXUIElement;
}

#pragma mark - Variables - dynamic

static MFScrollModificationResult _modifications;
static ScrollConfig *_scrollConfig;
static MFScrollAnimationCurveParameters *_animationParams;
static ScrollAnalysisResult _lastScrollAnalysisResult;
static CFTimeInterval _lastScrollAnalysisResultTimeStamp;
//static BOOL _isSuspended = NO; TODO: Remove suspension stuff (already commented out)

#pragma mark - Public functions

+ (void)load_Manual {
    
    /// Setup dispatch queue
    ///  For multithreading while still retaining control over execution order.
    dispatch_queue_attr_t attr = dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_SERIAL, QOS_CLASS_USER_INTERACTIVE, -1);
    _scrollQueue = dispatch_queue_create("com.nuebling.mac-mouse-fix.helper.scroll", attr);
    
    /// Create AXUIElement for getting app under mouse pointer
    _systemWideAXUIElement = AXUIElementCreateSystemWide();
    /// Create Event source
    if (_eventSource == nil) {
        _eventSource = CGEventSourceCreate(kCGEventSourceStateHIDSystemState);
    }
    
    /// Create/enable scrollwheel input callback
    if (_eventTap == nil) {
        CGEventMask mask = CGEventMaskBit(kCGEventScrollWheel);
        _eventTap = CGEventTapCreate(kCGHIDEventTap, kCGHeadInsertEventTap, kCGEventTapOptionDefault, mask, eventTapCallback, NULL);
        DDLogDebug(@"_eventTap: %@", _eventTap);
        CFRunLoopSourceRef runLoopSource = CFMachPortCreateRunLoopSource(kCFAllocatorDefault, _eventTap, 0);
        CFRunLoopAddSource(CFRunLoopGetCurrent(), runLoopSource, kCFRunLoopCommonModes);
        CFRelease(runLoopSource);
        CGEventTapEnable(_eventTap, false); // Not sure if this does anything
    }
    
    /// Create animator
    _animator = [[TouchAnimator alloc] init];
    
    /// Create initial config instance
    ///     Edit: I don't think this makes sense. `_scrollConfig` will be retrieved as necessary on first consecutive ticks
    _scrollConfig = nil; /// [[ScrollConfig alloc] init];
}

+ (void)resetState {
    dispatch_async(_scrollQueue, ^{
        resetState_Unsafe();
    });
}
void resetState_Sync(void) {
    
    /// TODO: I just saw a crash here where _scrollQueue was nil
    
    dispatch_sync(_scrollQueue, ^{
        resetState_Unsafe();
    });
}
void resetState_Unsafe(void) {
    DDLogDebug(@"reset-animator");
    [_animator cancel];
    [GestureScrollSimulator stopMomentumScroll]; /// Not sure if appropriate
    [ScrollAnalyzer resetState];
}

//+ (void)suspend {
//    /// Needs stop any output being generated by this class and *then* return
//    dispatch_sync(_scrollQueue, ^{
//        [_animator cancel];
//        _isSuspended = true;
//    });
//}

+ (void)start {
    
//    dispatch_async(_scrollQueue, ^{ /// Not sure why exactly this is on the queue
    CGEventTapEnable(_eventTap, true);
//    });
}

+ (void)stop {
        
    /// NOTES:
    /// - Are there other things we should enable/disable here? ScrollModifiers.reactToModiferChange() comes to mind
    /// - We check for isEnabled first because resetState uses `dispatch` which is pretty slow since this is called a lot by SwitchMaster
    
    if (CGEventTapIsEnabled(_eventTap)) {
        CGEventTapEnable(_eventTap, false);
        [self resetState];
    }
    
    
//    dispatch_async(_scrollQueue, ^{
//        resetState_Unsafe();
//        if (_eventTap) { /// Why are we checking if the eventTap exists here?
//            CGEventTapEnable(_eventTap, false);
//        }
//    });
}

+ (BOOL)isRunning {
    /// At the time of writing we just need this for debugging. Should'nt ever need it for something else I think.
    return CGEventTapIsEnabled(_eventTap);
}

#pragma mark - Event tap

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-function"

static NSString *CGScrollWheelEventDescription(CGEventRef event) {
    
    /// Helper / debugging function
    /// TODO: Move this to another file (Don't forget the -Wunused-function warning ignore stuff above and below)
    
    double d            = CGEventGetDoubleValueField(event, kCGScrollWheelEventDeltaAxis1);
    double dPoint       = CGEventGetDoubleValueField(event, kCGScrollWheelEventPointDeltaAxis1);
    double dFixed       = CGEventGetDoubleValueField(event, kCGScrollWheelEventFixedPtDeltaAxis1);
    double dContinuous  = CGEventGetIntegerValueField(event, kCGScrollWheelEventIsContinuous);
    double dCount       = CGEventGetDoubleValueField(event, kCGScrollWheelEventScrollCount);
    double dInstant     = CGEventGetDoubleValueField(event, kCGScrollWheelEventInstantMouser);
    double dPhase       = CGEventGetDoubleValueField(event, kCGScrollWheelEventScrollPhase);
    double dMomPhase    = CGEventGetDoubleValueField(event, kCGScrollWheelEventMomentumPhase);
    
    NSString *description = [NSString stringWithFormat:@"d: %f dPoint: %f dFixed: %f isContinuous: %f count: %f instant: %f phase: %f momPhase: %f", d, dPoint, dFixed, dContinuous, dCount, dInstant, dPhase, dMomPhase];
    
    return description;
}

#pragma clang diagnostic pop

static CGEventRef eventTapCallback(CGEventTapProxy proxy, CGEventType type, CGEventRef event, void *userInfo) {
    
    
    /// Debug
    
//    DDLogDebug(@"SCROOOL EVENT – %@", CGScrollWheelEventDescription(event));
    
    /// Handle eventTapDisabled messages
    
    if (type == kCGEventTapDisabledByTimeout || type == kCGEventTapDisabledByUserInput) {

        DDLogDebug(@"Scroll.m eventTap was disabled by %@", type == kCGEventTapDisabledByTimeout ? @"timeout. Re-enabling." : @"user input.");
        
        if (type == kCGEventTapDisabledByTimeout) {
            CGEventTapEnable(_eventTap, true);
        }
        
        return event;
    }
    
    /// Testing
    
//    IOHIDDeviceRef sendingDev = CGEventGetSendingDevice(event);

    /// Return non-scrollwheel events unaltered
    
    int64_t isPixelBased     = CGEventGetIntegerValueField(event, kCGScrollWheelEventIsContinuous);
    int64_t scrollPhase      = CGEventGetIntegerValueField(event, kCGScrollWheelEventScrollPhase);
    int64_t scrollDeltaAxis1 = CGEventGetIntegerValueField(event, kCGScrollWheelEventPointDeltaAxis1);
    int64_t scrollDeltaAxis2 = CGEventGetIntegerValueField(event, kCGScrollWheelEventPointDeltaAxis2);
    int64_t drawingTabletID  = CGEventGetIntegerValueField(event, kCGTabletEventDeviceID);
    bool isDiagonal = scrollDeltaAxis1 != 0 && scrollDeltaAxis2 != 0;
    if (isPixelBased != 0
        || scrollPhase != 0 /// Not entirely sure if testing for 'scrollPhase' here makes sense
        || drawingTabletID != 0 /// Untested
        || isDiagonal) {
        
        return event;
    }
    
    /// Get timestamp
    ///     Get timestamp here instead of _scrollQueue for accurate timing
    
    CFTimeInterval tickTime = CGEventGetTimestampInSeconds(event);
    
    /// Create copy of event
    
    CGEventRef eventCopy = CGEventCreateCopy(event); /// Create a copy, because the original event will become invalid and unusable in the new queue.
    
    /// Enqueue heavy processing
    ///  Executing heavy stuff on a different thread to prevent the eventTap from timing out. We wrote this before knowing that you can just re-enable the eventTap when it times out. But this doesn't hurt.
    
    dispatch_async(_scrollQueue, ^{
        heavyProcessing(eventCopy, scrollDeltaAxis1, scrollDeltaAxis2, tickTime);
    });
    
    return nil;
}

#pragma mark - Main event processing

static void heavyProcessing(CGEventRef event, int64_t scrollDeltaAxis1, int64_t scrollDeltaAxis2, CFTimeInterval tickTime) {
    
    /// Declare stuff for later
    static DriverUnsuspender unsuspendDrivers = ^{};
    
    /// Debug
    if (runningPreRelease()) { /// if-statement because hidEvent.description is very slow
        
        /// Get HIDEvent
        HIDEvent *hidEvent = CGEventGetHIDEvent(event);
        DDLogDebug(@"Scroll event: %@", hidEvent.description);
        
        
        /// Get sending device
        IOHIDDeviceRef sendingDev = CGEventGetSendingDevice(event);
        
        /// Debug
        assert(sendingDev != NULL);
        
        /// Print info on sendingDev
        if (sendingDev != NULL) {
            
            CFStringRef name = IOHIDDeviceGetProperty(sendingDev, CFSTR(kIOHIDProductKey));
            CFStringRef manufacturer = IOHIDDeviceGetProperty(sendingDev, CFSTR(kIOHIDManufacturerKey));
            
            DDLogDebug(@"Device sending scroll: %@ %@", manufacturer, name);
        }
    }

    /// Get axis
    
    MFAxis inputAxis = [ScrollUtility axisForVerticalDelta:scrollDeltaAxis1 horizontalDelta:scrollDeltaAxis2];
    
    /// Get scrollDelta
    
    int64_t scrollDelta = 0;
    
    if (inputAxis == kMFAxisVertical) {
        scrollDelta = scrollDeltaAxis1;
    } else if (inputAxis == kMFAxisHorizontal) {
        scrollDelta = scrollDeltaAxis2;
    } else {
        NSCAssert(NO, @"Invalid scroll axis");
    }
    
    /// Initialized scrollConfig for preliminary analysis
    /// Could also use `[ScrollConfig scrollConfigWithModifiers:inputAxis:event:]` here? It probably doesn't matter. This should only happen once on the very first tick after the helper starts.
    
    if (_scrollConfig == nil) {
        _scrollConfig = ScrollConfig.shared;
    }
    
    /// Run preliminary scrollAnalysis
    ///     To check if this is the first consecutive scrollTick
    ///
    ///     @note We check the `_modifications.effectMod` before updating `_modifications`. Not totally sure this makes sense?
    
    MFDirection scrollDirection = [ScrollUtility directionForInputAxis:inputAxis inputDelta:scrollDelta invertSetting:_scrollConfig.u_invertDirection horizontalModifier:(_modifications.effectMod == kMFScrollEffectModificationHorizontalScroll)];
    
    BOOL firstConsecutive = [ScrollAnalyzer peekIsFirstConsecutiveTickWithTickOccuringAt:tickTime direction:scrollDirection config:_scrollConfig];
    
    ///
    /// Update stuff
    ///     on the first scrollTick
    
    if (firstConsecutive) {
        /// Checking which app is under the mouse pointer and the other stuff we do here is really slow, so we only do it when necessary
        
        /// Disable suspension
//        _isSuspended = NO;
        
        /// Notify TrialCounter.swift
        [TrialCounter.shared handleUse];
        
        /// Update active device
        [HelperState updateActiveDeviceWithEvent:event];
        
        /// Update application Overrides
        
        if ((NO)) { /// Unused in MMF 3
            
            [ScrollUtility updateMouseDidMoveWithEvent:event];
            if (!ScrollUtility.mouseDidMove) {
                [ScrollUtility updateFrontMostAppDidChange];
                /// Only checking this if mouse didn't move, because of || in (mouseMoved || frontMostAppChanged). For optimization. Not sure if significant.
            }
            
            if (ScrollUtility.mouseDidMove || ScrollUtility.frontMostAppDidChange) {
                
                /// Set app overrides
                DDLogDebug(@"Frontmost app did change. Reloading config overrides.");
                BOOL didChange = [Config.shared loadOverridesForAppUnderMousePointerWithEvent:event];
                if (didChange) {
                    DDLogDebug(@"Config did change. Resetting state.");
                    resetState_Unsafe();
                }
            }
        }
        
        /// Notify other touch drivers
        
        if ((NO)) { /// Unused
            
//            DriverUnsuspender thisDriverUnsuspender = [OutputCoordinator suspendTouchDriversFromDriver:kTouchDriverScroll];
//            if (thisDriverUnsuspender != nil) {
//                unsuspendDrivers = thisDriverUnsuspender;
//            }
        }
        
        /// Update modfications
        MFScrollModificationResult newMods = [ScrollModifiers currentModificationsWithEvent:event];
        if (![ScrollModifiers scrollModsAreEqual:newMods other:_modifications]) {
            resetState_Unsafe();
            _modifications = newMods;
        }
        
        /// Get display  under mouse pointer
        CGDirectDisplayID displayID;
        [HelperUtility displayUnderMousePointer:&displayID withEvent:event];
        
        /// Get scrollConfig
        _scrollConfig = [ScrollConfig scrollConfigWithModifiers:newMods inputAxis:inputAxis display:displayID];
        
    } /// End `if (firstConsecutive) {`
    
    ///
    /// Get effective direction
    ///  -> With user settings etc. applied
    
    scrollDirection = [ScrollUtility directionForInputAxis:inputAxis inputDelta:scrollDelta invertSetting:_scrollConfig.u_invertDirection horizontalModifier:(_modifications.effectMod == kMFScrollEffectModificationHorizontalScroll)]; /// Why do we need to get the scrollDirection again? We already calculated it during the "preliminary scrollAnalysis". Can it ever change betweent he 2 times we calculate it?
    
    /// Run full scrollAnalysis
    ScrollAnalysisResult scrollAnalysisResult = [ScrollAnalyzer updateWithTickOccuringAt:tickTime direction:scrollDirection config:_scrollConfig];

    
    /// Store scrollAnalysisResult
    ///     So that command tab output code can access it. Not sure if good solution
    _lastScrollAnalysisResult = scrollAnalysisResult;
    _lastScrollAnalysisResultTimeStamp = CACurrentMediaTime();
    
    /// Debug
    DDLogDebug(@"Scroll analysisResult: %@", [ScrollAnalyzer scrollAnalysisResultDescription:scrollAnalysisResult]);
    
    
    /// Make scrollDelta positive, now that we have scrollDirection stored
    scrollDelta = llabs(scrollDelta);
    
    /// Return if suspended (so we dont' send any events)
//    if (_isSuspended) {
//        return;
//    }
    
    ///
    /// Acceleration (Get pxToScrollForThisTick)
    ///
    
    /// @discussion See the RawAccel guide for more info on acceleration curves https://github.com/a1xd/rawaccel/blob/master/doc/Guide.md
    ///     -> Edit: Their whole shtick is to make the outputSpeed(inputSpeed) curve smooth. This is relatively hard and I don't think this would be noticable for scrolling. Instead we simply define a sens(inputSpeed) curve using a Bezier curve.
    
    int64_t pxToScrollForThisTick;
    
    if (_scrollConfig.useAppleAcceleration) {
        
        pxToScrollForThisTick = scrollDelta;
        
    } else {
        
        /// Get scroll speed
        double timeBetweenTicks = scrollAnalysisResult.timeBetweenTicks;
        timeBetweenTicks = CLIP(timeBetweenTicks, 0, _scrollConfig.consecutiveScrollTickIntervalMax);
        /// ^ Shouldn't we clip between consecutiveScrollTickIntervalMin (instead of 0) and consecutiveScrollTickIntervalMax?
        ///     Also I think scrollAnalyzer should only produce these values and we should put an assert here instead
        
        double scrollSpeed = 1/timeBetweenTicks; /// In tick/s

        /// Evaluate acceleration curve
        Curve *accelerationCurve = _scrollConfig.accelerationCurve;
        assert(accelerationCurve != nil);
        double pxForThisTickDouble = [accelerationCurve evaluateAt:scrollSpeed]; /// In px/s
        pxToScrollForThisTick = pxForThisTickDouble; /// We could use a SubPixelator balance out the rounding errors, but I don't think that'll be noticable
        
        /// Debug
        DDLogDebug(@"Acceleration curve f(%f) = %lld", scrollSpeed, pxToScrollForThisTick);
        
        /// Validate
        if (pxToScrollForThisTick <= 0) {
            DDLogError(@"pxForThisTick is smaller equal 0. This is invalid. Exiting. scrollSpeed: %f, pxForThisTick: %lld", scrollSpeed, pxToScrollForThisTick);
            assert(false);
        }
        
        ///
        /// Apply fast scroll to pxToScrollForThisTick
        ///
        
        if (_scrollConfig.fastScrollCurve != nil) {
            
            /// Evaluate fast scroll
            /// +1 cause consecutiveScrollSwipeCounter starts counting at 0, and fsThreshold at 1
            double consecutiveSwipes = scrollAnalysisResult.consecutiveScrollSwipeCounter;
            double fastScrollFactor = [_scrollConfig.fastScrollCurve evaluateAt:consecutiveSwipes+1];
            
            /// LImit fastScroll
            /// - Limit it to 100,000, which is still super extreme, but it can grow far FAR larger. Especially with a free spinning wheel.
            /// - If it gets into the trillions things will still work properly, but the animations times might be several hours long which we obviously don't want
            /// - 100.000 still lets you scroll the world's longest website in a few seconds.
            /// - Edit: We also limit the animationDuration in TouchAnimator now, so this might not be necessary or useful anymore
            if (fastScrollFactor > 100000) fastScrollFactor = 100000;
            
            /// Apply fastScroll
            pxToScrollForThisTick *= fastScrollFactor;
        }
        
        
        /// Debug
        
        DDLogDebug(@"consecTicks: %lld, consecSwipes: %lld, consecSwipesFree: %f", scrollAnalysisResult.consecutiveScrollTickCounter, scrollAnalysisResult.DEBUG_consecutiveScrollSwipeCounterRaw, scrollAnalysisResult.consecutiveScrollSwipeCounter);
        
        DDLogDebug(@"timeBetweenTicks: %f, timeBetweenTicksRaw: %f, diff: %f, ticks: %lld", scrollAnalysisResult.timeBetweenTicks, scrollAnalysisResult.DEBUG_timeBetweenTicksRaw, scrollAnalysisResult.timeBetweenTicks - scrollAnalysisResult.DEBUG_timeBetweenTicksRaw, scrollAnalysisResult.consecutiveScrollTickCounter);
    }
    
    ///
    /// Send scroll events
    ///
    
    if (pxToScrollForThisTick == 0) {
        
        DDLogWarn(@"pxToScrollForThisTick is 0");
        
    } else if (!_scrollConfig.smoothEnabled) {
        
        /// Send scroll event directly - without the animator. Will scroll all of pxToScrollForThisTick at once.
        
        sendScroll(pxToScrollForThisTick, scrollDirection, NO, kMFAnimationCallbackPhaseNone, kMFMomentumHintNone, _scrollConfig);
        
    } else {
        
        /// Send scroll events through animator, spread out over time.
        
        /// Create config-copy for animation-callback-block
        ///  Edit: Turned copying off now, since it's extremely slow. I don't think this is necessary with the current architecture (the `_scrollConfig` is a reference into a cache. When the scrollConfig updates the cache is deleted but this reference should still be valid)
        
//        ScrollConfig *configCopyForBlock = [_scrollConfig copy];
        ScrollConfig *configCopyForBlock = _scrollConfig;
        
        /// Start animation
        
        [_animator startWithParams:^NSDictionary<NSString *,id> * _Nonnull(Vector valueLeftVec, BOOL isRunning, Curve *animationCurve) {
            
            /// Validate
            assert(valueLeftVec.x == 0 || valueLeftVec.y == 0);
            
            /// Link to main screen
            ///     This used to be above in the `isFirstConsecutive` section. Maybe it fits better there?
            if (ScrollUtility.mouseDidMove && !isRunning) {
                /// Update animator to currently used display
                [_animator linkToMainScreen_Unsafe];
            }
            
            /// Declare result dict (animator start params)
            NSMutableDictionary *p = [NSMutableDictionary dictionary];
            
            /// Get px that the animator still wants to scroll
            double pxLeftToScroll = 0.0;
            
            if (isRunning) {
                
                double distanceLeft = magnitudeOfVector(valueLeftVec);
                
                BOOL isSwipeSequenceStart = scrollAnalysisResult.consecutiveScrollTickCounter == 0 && scrollAnalysisResult.consecutiveScrollSwipeCounter == 0;
                
                if (isSwipeSequenceStart) { /// Checking for isRunning here leads to lost input when the computer is slow
                    
                    /// Reset pxLeftToScroll
                    pxLeftToScroll = 0.0;
                    [_animator resetSubPixelator_Unsafe];
                    
                } else if ([animationCurve isKindOfClass:SimpleBezierHybridCurve.class]) {
                    
                    assert(false); /// Unused - remove
                    
                    SimpleBezierHybridCurve *c = (SimpleBezierHybridCurve *)animationCurve;
                    pxLeftToScroll = [c baseDistanceLeftWithDistanceLeft: distanceLeft]; /// If we feed valueLeft instead of baseValueLeft back into the animator, it will lead to unwanted acceleration
                } else {
                    pxLeftToScroll = distanceLeft;
                }
            } else {
                pxLeftToScroll = 0.0;
                [_animator resetSubPixelator_Unsafe]; /// Maybe it would make more sense to do this automatically inside the animator? That might lead to problems with click and drag smoothing.
            }
            
            /// Calculate distance to scroll
            double delta = pxToScrollForThisTick + pxLeftToScroll;
            double duration;
            
            /// Create curve
            MFScrollAnimationCurveParameters *cParams = _scrollConfig.animationCurveParams;
            
            Curve *c;
            if (cParams.useDragCurve) {
                
                DDLogDebug(@"Scroll.m start animation curve hybrid");
                
                HybridCurve *hc = [[BezierHybridCurve alloc]
                     initWithBaseCurve:cParams.baseCurve
                     minDuration:((double)cParams.baseMsPerStep) / 1000.0
                     distance:delta
                     dragCoefficient:cParams.dragCoefficient
                     dragExponent:cParams.dragExponent
                     stopSpeed:cParams.stopSpeed
                     distanceEpsilon:0.2];
                
                duration = hc.duration;
                
                /// Validate
                assert(fabs(hc.distance - delta) < 3);
                /// Debug
                DDLogDebug(@"pre-animator - distance %f, duration: %f", hc.distance, hc.duration);
    //            DDLogDebug(@"\nDuration pre-animator: %f base: %f", c.duration, c.baseDuration);
                
                /// Assign
                c = hc;
                
            } else {
                DDLogDebug(@"Scroll.m start animation curve base");
                c = cParams.baseCurve;
                duration = ((double)cParams.baseMsPerStep) / 1000.0;
            }
            
            
            /// Fill return dict
            
            p[@"duration"] = @(duration);
            p[@"vector"] = nsValueFromVector(vectorFromDeltaAndDirection(delta, scrollDirection));
            p[@"curve"] = c;
            
            static double scrollDeltaSum = 0;
            scrollDeltaSum += labs(pxToScrollForThisTick);
//            DDLogDebug(@"Delta sum pre-animator: %f", scrollDeltaSum);
            
            /// Return
            return p;
            
        } integerCallback:^(Vector distanceDeltaVec, MFAnimationCallbackPhase animationPhase, MFMomentumHint momentumHint) {
            
            /// This will be called each frame
            
            /// Extract 1d delta from vec
            double distanceDelta = magnitudeOfVector(distanceDeltaVec);
            
            /// Get reference to copy of config specific for this block
            ///     Use this instead of the global `_scrollConfig` to avoid race conditions
            ScrollConfig *config = configCopyForBlock;
            
            /// Unsuspend
            if (animationPhase != kMFAnimationCallbackPhaseStart && animationPhase != kMFAnimationCallbackPhaseContinue) {
                unsuspendDrivers();
            }
            
            /// Validate
            assert(distanceDeltaVec.x == 0 || distanceDeltaVec.y == 0);
            
            if (distanceDelta == 0) {
                assert(animationPhase == kMFAnimationCallbackPhaseEnd || animationPhase == kMFAnimationCallbackPhaseCanceled);
            }
            /// Debug
            static double scrollDeltaSummm = 0;
            scrollDeltaSummm += distanceDelta;
//            DDLogDebug(@"Delta sum in-animator: %f", scrollDeltaSummm);
//            DDLogDebug(@"in-animator - delta %f, animationPhase: %d, momentumHint: %d", distanceDelta, animationPhase, momentumHint);
            if (animationPhase == kMFAnimationCallbackPhaseStart) {
                DDLogDebug(@"Start in-animator");
            }
            
            /// Send scroll
            sendScroll(distanceDelta, scrollDirection, YES, animationPhase, momentumHint, config);
            
        }];
    }
    
    CFRelease(event);
}

#pragma mark - Send Scroll events

static void sendScroll(int64_t px, MFDirection scrollDirection, BOOL animated, MFAnimationCallbackPhase animationPhase, MFMomentumHint momentumHint, ScrollConfig *config) {
    
    /// Get x and y deltas
    
    int64_t dx = 0;
    int64_t dy = 0;
    
    if (scrollDirection == kMFDirectionUp) {
        dy = px;
    } else if (scrollDirection == kMFDirectionDown) {
        dy = -px;
    } else if (scrollDirection == kMFDirectionLeft) {
        dx = -px;
    } else if (scrollDirection == kMFDirectionRight) {
        dx = px;
    } else if (scrollDirection == kMFDirectionNone) {
        
    } else {
        assert(false);
    }
    
    /// Get params for sending event
    
    MFScrollOutputType outputType;
    
    if (!animated) {
        outputType = kMFScrollOutputTypeLineScroll;
    } else {
        if (config.animationCurveParams.sendGestureScrolls) {
            outputType = kMFScrollOutputTypeGestureScroll;
        } else {
            outputType = kMFScrollOutputTypeContinuousScroll;
        }
    }
    
    if (_modifications.effectMod == kMFScrollEffectModificationZoom) {
        outputType = kMFScrollOutputTypeZoom;
    } else if (_modifications.effectMod == kMFScrollEffectModificationRotate) {
        outputType = kMFScrollOutputTypeRotation;
    } else if (_modifications.effectMod == kMFScrollEffectModificationFourFingerPinch) {
        outputType = kMFScrollOutputTypeFourFingerPinch;
    } else if (_modifications.effectMod == kMFScrollEffectModificationCommandTab) {
        outputType = kMFScrollOutputTypeCommandTab;
    } else if (_modifications.effectMod == kMFScrollEffectModificationThreeFingerSwipeHorizontal) {
        outputType = kMFScrollOutputTypeThreeFingerSwipeHorizontal;
    } /// kMFScrollEffectModificationHorizontalScroll is handled above when determining scroll direction
    
    /// Send event
    
    sendOutputEvents(dx, dy, outputType, animationPhase, momentumHint, config);
}

/// Define output types

typedef enum {
    kMFScrollOutputTypeGestureScroll,
    kMFScrollOutputTypeContinuousScroll,
    kMFScrollOutputTypeLineScroll,
    kMFScrollOutputTypeFourFingerPinch,
    kMFScrollOutputTypeThreeFingerSwipeHorizontal,
    kMFScrollOutputTypeZoom,
    kMFScrollOutputTypeRotation,
    kMFScrollOutputTypeCommandTab,
} MFScrollOutputType;

/// Output

static void sendOutputEvents(int64_t dx, int64_t dy, MFScrollOutputType outputType, MFAnimationCallbackPhase animatorPhase, MFMomentumHint momentumHint, ScrollConfig *config) {
    
    /// Init eventPhase
    
    IOHIDEventPhaseBits eventPhase = kIOHIDEventPhaseUndefined;
    if (animatorPhase != kMFAnimationCallbackPhaseNone) {
        eventPhase = [TouchAnimator IOHIDPhaseWithAnimationCallbackPhase:animatorPhase];
    }
    
    /// Debug
    if (animatorPhase == kMFAnimationCallbackPhaseCanceled) {
        
    }
    
    /// Validate
    
    if (dx+dy == 0) {
        assert(eventPhase == kIOHIDEventPhaseEnded || eventPhase == kIOHIDEventPhaseCancelled);
    }
    
    if (runningPreRelease()) {
        
        static CFTimeInterval lastTs = 0.0;
        CFTimeInterval ts = CACurrentMediaTime();
        CFTimeInterval tsDiff = ts - lastTs;
        lastTs = ts;
        
        DDLogDebug(@"\nHNGG: Posting event from scrollwheel: dx: %lld, dy: %lld, type: %d, phase: %d, momentum: %d, time: %d", dx, dy, outputType, animatorPhase, momentumHint, (int)(tsDiff*1000));
    }
    
    /// Send events based on outputType
    
    if (outputType == kMFScrollOutputTypeGestureScroll) {
        
        /// --- GestureScroll ---
        
        if (!config.animationCurveParams.sendMomentumScrolls) {
            
            if (eventPhase != kIOHIDEventPhaseEnded) {
                
                /// Post event
                [GestureScrollSimulator postGestureScrollEventWithDeltaX:dx deltaY:dy phase:eventPhase autoMomentumScroll:YES invertedFromDevice:_scrollConfig.invertedFromDevice];
                
            } else {
                
                /// Post end event
                [GestureScrollSimulator postGestureScrollEventWithDeltaX:0.0 deltaY:0.0 phase:kIOHIDEventPhaseEnded autoMomentumScroll:YES invertedFromDevice:_scrollConfig.invertedFromDevice];
                
                /// Debug
                DDLogDebug(@"THAT CALL where displayLinkkk is stopped from Scroll.m");
                
                /// Suppress momentumScroll
                /// - Only works if autoMomentumScroll is set to YES
                /// - ...That's because This architecture is so complicated but idk how to make it better. The idea behind it was that certain apps like Xcode have their own automatic momentumScrolling built in. To stop it you need to send an explicit 'momentumStop' event. Even if you haven't sent any other momentum events beforehand. Why not just send the momentumStop event directly? Here are our reasons (not sure if they are good) To lower the chances of any misbehaviour our approach was to simulate the trackpad behaviour as closely as possible. That means we start momentumScrolling automatically (hence `autoMomentumScroll:YES`) and then we simulate a finger touching the trackpad immediately. However, in this scenario, since we start and then stop the autoMomentumScroll immediately, the TouchAnimator which is started for autoMomentumScroll never calls its callback at all! So this is sort of nonsensical. Butttt we're also using `autoMomentumScroll:YES` for Click and Drag so I guess it might be simpler to do it this way since we need the autoMomentumScroll implementation anyways. Another reason for the architecture is that we decided to call the cancel callback from our autoMomentum TouchAnimator callback because that puts it inline with the other events sending and therefore makes stuff easier to think about (??) and provides more context info when we call the callback (?).
                
                [GestureScrollSimulator stopMomentumScroll];
            }
            
        } else { /// sendMomentumScrolls == true
            
            /// Validate
            assert(momentumHint != kMFMomentumHintNone);
            
            /// Store lastMomentumHint
            static MFMomentumHint lastMomentumHint = kMFMomentumHintNone;
            
            /// Get eventPhase and momentumPhase
            
            if (momentumHint == kMFMomentumHintGesture) { /// momentumHint is gesture
                
                if (lastMomentumHint == kMFMomentumHintMomentum) {
                    
                    /// Send momentum end event
                    [GestureScrollSimulator postMomentumScrollDirectlyWithDeltaX:0 deltaY:0 momentumPhase:kCGMomentumScrollPhaseEnd invertedFromDevice:_scrollConfig.invertedFromDevice];
                    
                    /// Set eventPhase to start
                    eventPhase = kIOHIDEventPhaseBegan;
                    
                    /// Debug
                    DDLogDebug(@"\nHybrid event - momentum: (0, 0, %d) JJJ", kCGMomentumScrollPhaseEnd);
                }
                
                /// Send normal gesture scroll
                [GestureScrollSimulator postGestureScrollEventWithDeltaX:dx deltaY:dy phase:eventPhase autoMomentumScroll:NO invertedFromDevice:_scrollConfig.invertedFromDevice];
                
                /// Debug
                DDLogDebug(@"\nHybrid event - gesture: (%lld, %lld, %d)", dx, dy, eventPhase);
                
            } else { /// momentumHint is momentum
                
                CGMomentumScrollPhase momentumPhase = kCGMomentumScrollPhaseNone;
                
                if (lastMomentumHint == kMFMomentumHintGesture) {
                    /// Momentum begins
                    
                    /// Send gesture end event
                    [GestureScrollSimulator postGestureScrollEventWithDeltaX:0 deltaY:0 phase:kIOHIDEventPhaseEnded autoMomentumScroll:NO invertedFromDevice:_scrollConfig.invertedFromDevice];
                    
                    /// Get momentum phase
                    momentumPhase = kCGMomentumScrollPhaseBegin;
                    
                    /// Debug
                    DDLogDebug(@"\nHybrid event - gesture: (0, 0, %d) HHH", kIOHIDEventPhaseEnded);
                    
                } else if (lastMomentumHint == kMFMomentumHintMomentum) {
                    /// Momentum continues
                    
                    /// Get momentum phase
                    if (animatorPhase == kMFAnimationCallbackPhaseContinue) {
                        momentumPhase = kCGMomentumScrollPhaseContinue;
                    } else if (animatorPhase == kMFAnimationCallbackPhaseEnd || animatorPhase == kMFAnimationCallbackPhaseCanceled) {
                        momentumPhase = kCGMomentumScrollPhaseEnd;
                    } else {
                        assert(false);
                        DDLogDebug(@"\nHybrid event - Assert fail >:(");
                    }
                } else {
                    assert(false);
                }
                
                /// Send momentum event
                [GestureScrollSimulator postMomentumScrollDirectlyWithDeltaX:dx deltaY:dy momentumPhase:momentumPhase invertedFromDevice:_scrollConfig.invertedFromDevice];
                
                /// Debug
                DDLogDebug(@"\nHybrid event - momentum: (%lld, %lld, %d)", dx, dy, momentumPhase);
            }
            
            /// Update lastMomentumHint
            lastMomentumHint = momentumHint;
            if (animatorPhase == kMFAnimationCallbackPhaseEnd || animatorPhase == kMFAnimationCallbackPhaseCanceled) {
                DDLogDebug(@"HNGG reset lastMomentumHint");
                lastMomentumHint = kMFMomentumHintNone;
            }
        }
        
    } else if (outputType == kMFScrollOutputTypeContinuousScroll) {
        
        /// --- ContinuousScroll ---
        
        if (dx+dy == 0) return; /// Copied from lineScroll
        
        /// Create base event
        
        CGEventRef event = CGEventCreate(NULL);
        CGEventSetIntegerValueField(event, 55, 22); /// Set type to `kCGEventScrollWheel`
        CGEventSetIntegerValueField(event, kCGScrollWheelEventIsContinuous, 1);
        
        /// Setup subpixelator
        
        static VectorSubPixelator *linePixelator = nil;
        
        if (linePixelator == nil) {
            linePixelator = [VectorSubPixelator biasedPixelator];
        }
        if (animatorPhase == kMFAnimationCallbackPhaseStart) {
            [linePixelator reset];
        }
        
        /// Get alt deltas
        ///     Maybe we should reuse `GestureScrollSimulator` -> `getDeltaVectors()` here. Basically does the same.
        
        double dyLine = ((double)dy)/10.0;
        double dxLine = ((double)dx)/10.0;
        
        Vector pixelatedLines = [linePixelator intVectorWithDoubleVector:_P(dxLine, dyLine)];
        
        /// Set deltas
        
        CGEventSetIntegerValueField(event, kCGScrollWheelEventDeltaAxis1, pixelatedLines.y);
        CGEventSetIntegerValueField(event, kCGScrollWheelEventPointDeltaAxis1, dy);
        CGEventSetIntegerValueField(event, kCGScrollWheelEventFixedPtDeltaAxis1, fixedScrollDelta(pixelatedLines.y));
        
        CGEventSetIntegerValueField(event, kCGScrollWheelEventDeltaAxis2, pixelatedLines.x);
        CGEventSetIntegerValueField(event, kCGScrollWheelEventPointDeltaAxis2, dx);
        CGEventSetIntegerValueField(event, kCGScrollWheelEventFixedPtDeltaAxis2, fixedScrollDelta(pixelatedLines.x));
        
        /// Log
        
        if (runningPreRelease()) {
            
            static double tsStart = 0;
            if (animatorPhase == kMFAnimationCallbackPhaseStart) {
                tsStart = CACurrentMediaTime();
            }
            double ts = CACurrentMediaTime();
            double timeSinceStart = ts - tsStart;
            
            DDLogDebug(@"\nHNGG: Posting continuous scroll event: %@, momentumHint: %d, time: %d", scrollEventDescriptionWithOptions(event, YES, NO), momentumHint, (int)(timeSinceStart*1000));
        }
        
        /// Post event
        
        CGEventPost(kCGSessionEventTap, event);
        CFRelease(event);
        
    } else if (outputType == kMFScrollOutputTypeLineScroll) {
        
        /// --- LineScroll ---
        
        /// We ignore the phases here
        
        if (dx+dy == 0) return;
        
        /// Create base event
        
        /// Sol 1: Use `CGEventCreateScrollWheelEvent()`
        ///     - Mysterious: In the real events, `kCGScrollWheelEventIsContinuous` is false. But we have to set it true (through `kCGScrollEventUnitPixel`) to make the scroll distance match the real events.
        ///     - Safari makes the scroll distance larger than the pixels that are specified in lineScrollEvents. But that doesn't work here. Maybe it's becuase we're setting `kCGScrollWheelEventIsContinuous` true? We're just using
//        CGEventRef event = CGEventCreateScrollWheelEvent(NULL, kCGScrollEventUnitPixel, 1, 0);
        
        /// Sol 2: Just use `CGEventCreate`
        ///     - This is based on analysis of real events
        CGEventRef event = CGEventCreate(NULL);
        CGEventSetIntegerValueField(event, 55, 22); /// Set type to `kCGEventScrollWheel`
        
        /// Get line deltas
        ///     Line deltas are 1/10 of pixel deltas. See CGEventSource pixelsPerLine - it's 10
        double dyLine = ((double)dy) / 10;
        double dxLine = ((double)dx) / 10;
        
        /// Get line deltas as int
        ///     Int deltas are generally truncated but also rounded up to be at least 1 (or -1). This also happens in real events.
        int64_t dyLineInt = (int64_t)dyLine;
        int64_t dxLineInt = (int64_t)dxLine;
        if (fabs(dyLine) != 0 && llabs(dyLineInt) == 0) dyLineInt = sign(dyLine);
        if (fabs(dxLine) != 0 && llabs(dxLineInt) == 0) dxLineInt = sign(dxLine);
        
        /// Get line deltas as fixed point number
        int64_t dyLineFixed = fixedScrollDelta(dyLine);
        int64_t dxLineFixed = fixedScrollDelta(dxLine);
        
        /// Set fields
        ///     We used to have a comment here saying that the `FixedPtDelta`s were automatically being set when setting the `PointDelta`s. But under the Ventura Beta this doesn't seem to be true, so we're setting it manually.
        
        CGEventSetIntegerValueField(event, kCGScrollWheelEventDeltaAxis1, dyLineInt);
        CGEventSetIntegerValueField(event, kCGScrollWheelEventPointDeltaAxis1, dy);
        CGEventSetIntegerValueField(event, kCGScrollWheelEventFixedPtDeltaAxis1, dyLineFixed);
        
        CGEventSetIntegerValueField(event, kCGScrollWheelEventDeltaAxis2, dxLineInt);
        CGEventSetIntegerValueField(event, kCGScrollWheelEventPointDeltaAxis2, dx);
        CGEventSetIntegerValueField(event, kCGScrollWheelEventFixedPtDeltaAxis2, dxLineFixed);
        
        /// Debug
        DDLogDebug(@"SCROOOL OVONT – %@", CGScrollWheelEventDescription(event));
        
        /// Send
        CGEventPost(kCGSessionEventTap, event);
        
        /// Release
        CFRelease(event);
        
    } else if (outputType == kMFScrollOutputTypeZoom) {
        
        /// --- Zoom ---
        
        double eventDelta = (dx + dy)/800.0; /// This works because, if dx != 0 -> dy == 0, and the other way around.
        
        /// HACK:
        ///     Chromium browsers need a ton of zooming deltas before they actually start zooming. So we send a bunch of deltas right away to make things more responsive.
        ///     Another way to combat this would be to only send the `end` event when the user releases the modifier.
        if (eventPhase == kIOHIDEventPhaseBegan) {
            
            NSString *bundleID = [HelperUtility appUnderMousePointerWithEvent:NULL].bundleIdentifier;
            
            if (bundleID != nil) {
                if ([bundleID containsString:@"com.google.Chrome"]
                    || [bundleID containsString:@"org.chromium.Chromium"]
                    || [bundleID containsString:@"com.operasoftware.Opera"]
                    || [bundleID containsString:@"com.microsoft.edgemac"]
                    || [bundleID containsString:@"com.vivaldi.Vivaldi"]
                    || [bundleID containsString:@"com.brave.Browser"]) {
                    
                    /// Using `containsString` to also catch other release channels like "com.google.Chrome.canary".
                    /// TODO: Add other Chromium browsers with the same behaviour.
                    /// Notes:
                    /// - Blisk (org.blisk.Blisk) and Colibri (co.opqr.colibri) don't seem to support pinch to zoom.
                    
                    [TouchSimulator postMagnificationEventWithMagnification:eventDelta phase:kIOHIDEventPhaseBegan]; /// First delta seems to be ignored
                    eventPhase = kIOHIDEventPhaseChanged;
                    
                    assert(eventDelta != 0);
                    if (sign(eventDelta) > 0) {
                        eventDelta += 380/800.0;
                    } else {
                        eventDelta -= 250/800.0;
                    }
                }
            }
        }
        
        [TouchSimulator postMagnificationEventWithMagnification:eventDelta phase:eventPhase];
        
    } else if (outputType == kMFScrollOutputTypeRotation) {
        
        /// --- Rotation ---
        
        double eventDelta = (dx + dy)/8.0; /// This works because, if dx != 0 -> dy == 0, and the other way around.
        
        [TouchSimulator postRotationEventWithRotation:eventDelta phase:eventPhase];
        
    } else if (outputType == kMFScrollOutputTypeFourFingerPinch
               || outputType == kMFScrollOutputTypeThreeFingerSwipeHorizontal) {
        
        /// --- FourFingerPinch or ThreeFingerSwipeHorizontal ---
        
        MFDockSwipeType type;
        double eventDelta;
        
        if (outputType == kMFScrollOutputTypeFourFingerPinch) {
            type = kMFDockSwipeTypePinch;
            eventDelta = (dx + dy)/600.0; /// Not sure why we need to negate here. Edit: Maybe to do with invertedFromDevice flag?
            /// ^ Launchpad feels a lot less sensitive than Show Desktop, but to improve this we'd have to somehow detect which of both is active atm.
        } else if (outputType == kMFScrollOutputTypeThreeFingerSwipeHorizontal) {
            type = kMFDockSwipeTypeHorizontal;
            eventDelta = -(dx + dy)/600.0; /// Should this be different than the pinch scaling?
        } else {
            assert(false);
        }
        
        [TouchSimulator postDockSwipeEventWithDelta:eventDelta type:type phase:eventPhase invertedFromDevice:_scrollConfig.invertedFromDevice];
        
    } else if (outputType == kMFScrollOutputTypeCommandTab) {
        
        /// --- CommandTab ---
        
        double d = -(dx + dy);
        
        if (d == 0) return;
        
        /// Get state
        
        static bool appSwitcherWasOpenedByCurrentConsecutiveTicks = false; /// Use this to make first swipe only create one selection change
        bool isFirstConsecutive = _lastScrollAnalysisResult.consecutiveScrollTickCounter == 0; /// When commandTab is active, we only get one call of this function per Tick (animator is disabled), that's why we can do this
        
        /// Open app switcher
        
        if (!_appSwitcherIsOpen) {
            sendKeyEvent(55, kCGEventFlagMaskCommand, true);
            sendKeyEvent(48, kCGEventFlagMaskCommand, true);
            sendKeyEvent(48, kCGEventFlagMaskCommand, false);
            _appSwitcherIsOpen = YES;
            appSwitcherWasOpenedByCurrentConsecutiveTicks = true;
        } else {
            if (isFirstConsecutive)
                appSwitcherWasOpenedByCurrentConsecutiveTicks = false;
        }
        
        /// Select apps
        
        if (!appSwitcherWasOpenedByCurrentConsecutiveTicks) {
            
            if (d > 0) {
                sendKeyEvent(48, kCGEventFlagMaskCommand, true);
                sendKeyEvent(48, kCGEventFlagMaskCommand, false);
            } else {
                sendKeyEvent(48, kCGEventFlagMaskCommand | kCGEventFlagMaskShift, true);
                sendKeyEvent(48, kCGEventFlagMaskCommand | kCGEventFlagMaskShift, false);
            }
        }
        
    } else {
        assert(false);
    }
    
}

/// Output - Helper funcs

static BOOL _appSwitcherIsOpen = NO;

+ (void)appSwitcherModificationHasBeenDeactivated {
    
    if (_appSwitcherIsOpen) { /// Not sure if this check is necessary. Should only be called when the appSwitcher is open.
        sendKeyEvent(55, 0, false);
        _appSwitcherIsOpen = NO;
    }
}

void sendKeyEvent(CGKeyCode keyCode, CGEventFlags flags, bool keyDown) {
    
    CGEventTapLocation tapLoc = kCGSessionEventTap;
    
    CGEventRef event = CGEventCreateKeyboardEvent(NULL, keyCode, keyDown);
    CGEventSetFlags(event, flags);
    
    CGEventPost(tapLoc, event);
    CFRelease(event);
}

@end
